<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 交互粒子圣诞树</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Helvetica Neue', sans-serif; }
        
        /* 3D 容器 */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* 摄像头预览 (圆形悬浮设计) */
        #video-container {
            position: absolute; bottom: 30px; left: 30px; width: 140px; height: 140px;
            z-index: 10; border-radius: 50%; overflow: hidden; 
            border: 3px solid rgba(255, 215, 0, 0.5); /* 金色边框 */
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
            transform: scaleX(-1);
            transition: 0.3s;
        }
        #video-container:hover { transform: scaleX(-1) scale(1.1); }
        #input-video { width: 100%; height: 100%; object-fit: cover; }

        /* UI 按钮组 */
        .ui-group {
            position: absolute; top: 30px; right: 30px; z-index: 10;
            display: flex; gap: 15px;
        }

        .glass-btn {
            background: rgba(255, 255, 255, 0.1);
            color: #FFD700; /* 金色文字 */
            border: 1px solid rgba(255, 215, 0, 0.3);
            padding: 10px 20px; border-radius: 30px;
            cursor: pointer; transition: 0.3s;
            font-weight: bold; letter-spacing: 1px;
            backdrop-filter: blur(10px);
            text-transform: uppercase;
            font-size: 12px;
        }
        .glass-btn:hover {
            background: rgba(255, 215, 0, 0.2);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
        }

        /* 加载遮罩 */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #020202;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            z-index: 999; color: #FFD700; transition: opacity 0.8s;
        }
        .spinner {
            width: 50px; height: 50px; border: 3px solid rgba(255, 215, 0, 0.1);
            border-top: 3px solid #FFD700; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        .loading-text { font-size: 14px; opacity: 0.8; letter-spacing: 2px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* 提示文字 */
        #hint {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.4); font-size: 14px; pointer-events: none; z-index: 5;
        }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loading-text" id="status-text">Creating Magic... (Loading AI)</div>
    </div>

    <div id="video-container">
        <video id="input-video" playsinline></video>
    </div>

    <div class="ui-group">
        <button class="glass-btn" id="toggle-cam">摄像头开关</button>
        <button class="glass-btn" id="fullscreen-btn">全屏体验</button>
    </div>
    
    <div id="hint">双手张合控制大小 • 单手捏合控制炸裂</div>

    <div id="canvas-container"></div>

    <!-- 脚本引入 -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js",
                "@mediapipe/camera_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 全局变量 ---
        let scene, camera, renderer, particles, ornamentParticles, textSprite;
        let positions, targetPositions; // 基础粒子位置
        let ornamentPositions, ornamentTargets; // 装饰粒子位置
        const PARTICLE_COUNT = 12000;
        const ORNAMENT_COUNT = 600;
        
        // 交互状态
        let interactionState = {
            scale: 1.0,     // 目标缩放
            spread: 0.0,    // 目标扩散程度
            currentScale: 1.0,
            currentSpread: 0.0,
            hasHands: false
        };

        // --- 1. 纹理生成器 (不依赖外部图片，保证运行稳定) ---
        
        // 生成圆形光晕纹理
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(0.4, 'rgba(255, 215, 0, 0.5)'); // 金色
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        // 生成雪花/星星纹理 (用于 Ornament 粒子)
        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.translate(32, 32);
            ctx.fillStyle = "#FFFFFF";
            for(let i=0; i<6; i++) {
                ctx.beginPath();
                ctx.moveTo(0,0); ctx.lineTo(0, -20);
                ctx.lineWidth = 4; ctx.strokeStyle = "white"; ctx.stroke();
                ctx.rotate(Math.PI / 3);
            }
            //加上光晕
            const grad = ctx.createRadialGradient(0,0,0, 0,0,25);
            grad.addColorStop(0, 'rgba(255,255,255,0.8)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(0,0,25,0,Math.PI*2); ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        // 生成 Merry Christmas 艺术字纹理
        function createTextTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // 发光效果
            ctx.shadowColor = "#FFD700";
            ctx.shadowBlur = 20;
            ctx.font = "italic bold 100px 'Georgia', serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            // 渐变文字
            const gradient = ctx.createLinearGradient(0, 0, 1024, 0);
            gradient.addColorStop(0, "#FFD700");
            gradient.addColorStop(0.5, "#FFF");
            gradient.addColorStop(1, "#FFD700");
            
            ctx.fillStyle = gradient;
            ctx.fillText("Merry Christmas", 512, 128);
            
            return new THREE.CanvasTexture(canvas);
        }

        // --- 2. Three.js 场景初始化 ---
        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02); // 黑色雾气增加深邃感

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            controls.maxDistance = 80;

            // 环境光
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            
            createTree();
            createOrnaments();
            createTitle();
        }

        // --- 3. 创建圣诞树粒子 (Math Logic) ---
        function createTree() {
            const geometry = new THREE.BufferGeometry();
            positions = new Float32Array(PARTICLE_COUNT * 3);
            targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);

            const color1 = new THREE.Color(0xFFD700); // 金色
            const color2 = new THREE.Color(0xFF4500); // 橙红色点缀

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // 初始位置随机散布
                positions[i*3] = (Math.random()-0.5) * 50;
                positions[i*3+1] = (Math.random()-0.5) * 50;
                positions[i*3+2] = (Math.random()-0.5) * 50;

                // 目标位置：螺旋圆锥
                // t 从 0 到 1 (底部到顶部)
                const t = Math.random(); 
                // 角度：随高度旋转
                const angle = t * Math.PI * 15 + Math.random() * 0.5; 
                // 半径：随高度减小，底部最大 15
                const radius = 12 * (1 - t) + Math.random() * 0.5; 
                
                // 螺旋核心形状
                let tx = Math.cos(angle) * radius;
                let ty = (t * 25) - 10; // 高度范围 -10 到 15
                let tz = Math.sin(angle) * radius;

                // 添加一些随机噪点让树看起来毛茸茸
                tx += (Math.random() - 0.5) * 1.5;
                ty += (Math.random() - 0.5) * 1.5;
                tz += (Math.random() - 0.5) * 1.5;

                targetPositions[i*3] = tx;
                targetPositions[i*3+1] = ty;
                targetPositions[i*3+2] = tz;

                // 颜色混入
                const mixColor = Math.random() > 0.8 ? color2 : color1;
                colors[i*3] = mixColor.r;
                colors[i*3+1] = mixColor.g;
                colors[i*3+2] = mixColor.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.35,
                map: createGlowTexture(),
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.9
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- 4. 创建装饰物粒子 (带图片的粒子) ---
        function createOrnaments() {
            const geometry = new THREE.BufferGeometry();
            ornamentPositions = new Float32Array(ORNAMENT_COUNT * 3);
            ornamentTargets = new Float32Array(ORNAMENT_COUNT * 3);

            for (let i = 0; i < ORNAMENT_COUNT; i++) {
                // 初始随机
                ornamentPositions[i*3] = (Math.random()-0.5) * 50;
                ornamentPositions[i*3+1] = (Math.random()-0.5) * 50;
                ornamentPositions[i*3+2] = (Math.random()-0.5) * 50;

                // 目标：依附在树表面
                const t = Math.random();
                const angle = Math.random() * Math.PI * 2;
                // 半径略大于树的半径
                const radius = 12 * (1 - t) + 1.0; 
                
                ornamentTargets[i*3] = Math.cos(angle) * radius;
                ornamentTargets[i*3+1] = (t * 25) - 10;
                ornamentTargets[i*3+2] = Math.sin(angle) * radius;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(ornamentPositions, 3));

            const material = new THREE.PointsMaterial({
                size: 1.2, // 更大
                map: createStarTexture(), // 雪花/星星纹理
                color: 0xFFFFFF,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 1.0
            });

            ornamentParticles = new THREE.Points(geometry, material);
            scene.add(ornamentParticles);
        }

        // --- 5. 创建 Merry Christmas 标题 ---
        function createTitle() {
            const map = createTextTexture();
            const material = new THREE.SpriteMaterial({ map: map, transparent: true, opacity: 0 });
            textSprite = new THREE.Sprite(material);
            textSprite.scale.set(20, 5, 1);
            textSprite.position.set(0, 18, 0); // 在树顶之上
            scene.add(textSprite);
        }

        // --- 6. MediaPipe 手势识别 ---
        async function setupMediaPipe() {
            const videoElement = document.getElementById('input-video');
            const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults((results) => {
                if(results.multiHandLandmarks.length > 0) {
                    interactionState.hasHands = true;
                    // --- 逻辑 ---
                    // 2只手 -> 距离决定 Scale
                    if (results.multiHandLandmarks.length === 2) {
                        const h1 = results.multiHandLandmarks[0][8]; // 食指
                        const h2 = results.multiHandLandmarks[1][8];
                        const dist = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                        
                        // 距离越大，Scale 越大 (0.1 -> 1.0)
                        // 映射: 0.2 -> 0.8
                        let target = (dist - 0.1) * 3.0;
                        interactionState.scale = Math.max(0.3, Math.min(2.0, target));
                        interactionState.spread = 0; // 双手时不炸开
                    } 
                    // 1只手 -> 捏合决定 Spread (爆炸)
                    else {
                        const h = results.multiHandLandmarks[0];
                        const thumb = h[4];
                        const index = h[8];
                        const pinchDist = Math.hypot(thumb.x - index.x, thumb.y - index.y);
                        
                        // 捏合(dist小) -> 正常，张开(dist大) -> 炸开
                        if (pinchDist > 0.15) {
                            interactionState.spread = (pinchDist - 0.15) * 10; // 炸开系数
                        } else {
                            interactionState.spread = 0;
                        }
                        interactionState.scale = 1.0; // 单手时不缩放
                    }
                } else {
                    interactionState.hasHands = false;
                }
            });

            const camera = new window.Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 320, height: 240
            });
            
            try {
                await camera.start();
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').remove(), 800);
            } catch (e) {
                console.error("Camera failed", e);
                document.getElementById('status-text').innerText = "摄像头启动失败 (请使用手动模式)";
                setTimeout(() => document.getElementById('loader').remove(), 2000);
            }
        }

        // --- 7. 动画循环 ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            
            // 平滑过渡交互数值
            const lerpSpeed = 0.05;
            // 如果没检测到手，慢慢恢复默认状态
            if (!interactionState.hasHands) {
                interactionState.scale = 1.0;
                interactionState.spread = 0.0;
            }

            interactionState.currentScale += (interactionState.scale - interactionState.currentScale) * lerpSpeed;
            interactionState.currentSpread += (interactionState.spread - interactionState.currentSpread) * lerpSpeed;

            const scale = interactionState.currentScale;
            const spread = interactionState.currentSpread;

            // 更新基础粒子 (Tree Dust)
            const pPositions = particles.geometry.attributes.position.array;
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const ix = i*3;
                let tx = targetPositions[ix] * scale;
                let ty = targetPositions[ix+1] * scale;
                let tz = targetPositions[ix+2] * scale;

                // 炸裂效果 (沿原点向外推)
                if(spread > 0.01) {
                    tx += tx * spread * 2;
                    ty += ty * spread * 2;
                    tz += tz * spread * 2;
                    // 加点混乱
                    tx += Math.sin(time * 10 + i) * spread;
                }

                // 简单的闪烁动画
                ty += Math.sin(time * 2 + tx * 0.5) * 0.05;

                // 移动粒子
                pPositions[ix] += (tx - pPositions[ix]) * 0.1;
                pPositions[ix+1] += (ty - pPositions[ix+1]) * 0.1;
                pPositions[ix+2] += (tz - pPositions[ix+2]) * 0.1;
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // 更新装饰粒子 (Ornaments)
            const oPositions = ornamentParticles.geometry.attributes.position.array;
            for(let i=0; i<ORNAMENT_COUNT; i++) {
                const ix = i*3;
                let tx = ornamentTargets[ix] * scale;
                let ty = ornamentTargets[ix+1] * scale;
                let tz = ornamentTargets[ix+2] * scale;

                if(spread > 0.01) {
                    tx += tx * spread * 3; // 装饰飞得更远
                    ty += ty * spread * 3;
                    tz += tz * spread * 3;
                }

                oPositions[ix] += (tx - oPositions[ix]) * 0.08;
                oPositions[ix+1] += (ty - oPositions[ix+1]) * 0.08;
                oPositions[ix+2] += (tz - oPositions[ix+2]) * 0.08;
            }
            ornamentParticles.geometry.attributes.position.needsUpdate = true;
            
            // 旋转整个树
            if (spread < 0.2) {
                particles.rotation.y = time * 0.1;
                ornamentParticles.rotation.y = time * 0.1;
            }

            // 更新标题动画 (淡入 + 浮动)
            if (textSprite) {
                textSprite.material.opacity += (1 - textSprite.material.opacity) * 0.02;
                textSprite.position.y = 18 * scale + Math.sin(time) * 0.5;
                // 当树炸裂时，标题也变大并淡出
                if (spread > 0.5) textSprite.material.opacity = 1 - spread;
            }

            renderer.render(scene, camera);
        }

        // --- 8. 事件监听 ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else document.exitFullscreen();
        });

        document.getElementById('toggle-cam').addEventListener('click', () => {
            const v = document.getElementById('video-container');
            v.style.display = v.style.display === 'none' ? 'block' : 'none';
        });

        // 启动
        initScene();
        setupMediaPipe();
        animate();

    </script>
</body>
</html>